extends CharacterBody2D

@export var speed := 150.0
@export var acceleration := 1000.0
@export var friction := 28
@export var gravity := 800.0
@export var jump_force := 300.0
@export var total_jumps := 2
@export var short_jump_threshold := 100

var _velocity: = Vector2.ZERO
var _jumps_left: = 0
var _jumped: = false
var _was_on_floor: = false

@onready var coyote_timer: = $CoyoteTimer
@onready var jump_buffer_timer: = $JumpBufferTimer



func _ready() -> void :
	Game.player = self

	assert (coyote_timer.connect("timeout", Callable(self, "_on_coyote_timer_timeout")) == OK)

	_jumps_left = total_jumps


func _physics_process(delta: float) -> void :
	_velocity.y += gravity * delta

	_update_movement(delta)
	_update_jump()

	_was_on_floor = is_on_floor()
	set_velocity(_velocity)
	set_up_direction(Vector2.UP)
	move_and_slide()
	_velocity = velocity



func jump() -> void :
	_jumped = true
	_jumps_left -= 1
	_velocity.y = - jump_force
	coyote_timer.stop()


func jump_cut() -> void :
	if _velocity.y < - short_jump_threshold:
		_velocity.y = - short_jump_threshold


func _update_movement(delta: float) -> void :
	var move_input = _poll_move_input()
	if move_input.x == 0:
		_velocity.x = lerp(0, _velocity.x, pow(2, - friction * delta))
	else:
		_velocity.x += move_input.x * acceleration * delta
		_velocity.x = clamp(_velocity.x, - speed, speed)


func _update_jump() -> void :
	if not _jumped and not is_on_floor() and _was_on_floor:
		coyote_timer.start()
	if is_on_floor():
		_jumps_left = total_jumps

	_jumped = false
	if is_on_floor() and not jump_buffer_timer.is_stopped():
		jump()
	elif Input.is_action_just_pressed("jump"):
		if _jumps_left > 0:
			jump()
		else:
			jump_buffer_timer.start()

	if Input.is_action_just_released("jump"):
		jump_cut()


func _poll_move_input() -> Vector2:
	return Input.get_vector("move_left", "move_right", "move_up", "move_down")



func _on_coyote_timer_timeout() -> void :
	_jumps_left = int(max(_jumps_left - 1, 0))
